{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport hash from '@emotion/hash';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from '../../linters';\nimport { useStyleInject, ATTR_CACHE_PATH, ATTR_MARK, ATTR_TOKEN, CSS_IN_JS_INSTANCE } from '../../StyleContext';\nimport { supportLayer } from '../../util';\nimport useGlobalCache from '../useGlobalCache';\nimport { removeCSS, updateCSS } from '../../../../vc-util/Dom/dynamicCSS';\nimport { computed } from 'vue';\nimport canUseDom from '../../../../_util/canUseDom';\nimport { ATTR_CACHE_MAP, existPath, getStyleAndHash, serialize as serializeCacheMap } from './cacheMapUtil';\nconst isClientSide = canUseDom();\nconst SKIP_CHECK = '_skip_check_';\nconst MULTI_VALUE = '_multi_value_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr) {\n  const serialized = serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return typeof value === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);\n}\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  const hashClassName = `.${hashId}`;\n  const hashSelector = hashPriority === 'low' ? `:where(${hashClassName})` : hashClassName;\n  // 注入 hashId\n  const keys = key.split(',').map(k => {\n    var _a;\n    const fullPath = k.trim().split(/\\s+/);\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    let firstPath = fullPath[0] || '';\n    const htmlElement = ((_a = firstPath.match(/^\\w+/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;\n    return [firstPath, ...fullPath.slice(1)].join(' ');\n  });\n  return keys.join(',');\n}\n// Global effect style will mount once and not removed\n// The effect will not save in SSR cache (e.g. keyframes)\nconst globalEffectStyleKeys = new Set();\n/**\n * @private Test only. Clear the global effect style keys.\n */\nexport const _cf = process.env.NODE_ENV !== 'production' ? () => globalEffectStyleKeys.clear() : undefined;\n// Parse CSSObject to style content\nexport const parseStyle = function (interpolation) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    root,\n    injectHash,\n    parentSelectors\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    root: true,\n    parentSelectors: []\n  };\n  const {\n    hashId,\n    layer,\n    path,\n    hashPriority,\n    transformers = [],\n    linters = []\n  } = config;\n  let styleStr = '';\n  let effectStyle = {};\n  function parseKeyframes(keyframes) {\n    const animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      const [parsedStr] = parseStyle(keyframes.style, config, {\n        root: false,\n        parentSelectors\n      });\n      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;\n    }\n  }\n  function flattenList(list) {\n    let fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(originStyle => {\n    // Only root level can use raw string\n    const style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += `${style}\\n`;\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      const mergedStyle = transformers.reduce((prev, trans) => {\n        var _a;\n        return ((_a = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a === void 0 ? void 0 : _a.call(trans, prev)) || prev;\n      }, style);\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(key => {\n        var _a;\n        const value = mergedStyle[key];\n        if (typeof value === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          let subInjectHash = false;\n          // 当成嵌套对象来处理\n          let mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          let nextRoot = false;\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          const [parsedStr, childEffectStyle] = parseStyle(value, config, {\n            root: nextRoot,\n            injectHash: subInjectHash,\n            parentSelectors: [...parentSelectors, mergedKey]\n          });\n          effectStyle = _extends(_extends({}, effectStyle), childEffectStyle);\n          styleStr += `${mergedKey}${parsedStr}`;\n        } else {\n          function appendStyle(cssKey, cssValue) {\n            if (process.env.NODE_ENV !== 'production' && (typeof value !== 'object' || !(value === null || value === void 0 ? void 0 : value[SKIP_CHECK]))) {\n              [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach(linter => linter(cssKey, cssValue, {\n                path,\n                hashId,\n                parentSelectors\n              }));\n            }\n            // 如果是样式则直接插入\n            const styleName = cssKey.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n            // Auto suffix with px\n            let formatValue = cssValue;\n            if (!unitless[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {\n              formatValue = `${formatValue}px`;\n            }\n            // handle animationName & Keyframe value\n            if (cssKey === 'animationName' && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {\n              parseKeyframes(cssValue);\n              formatValue = cssValue.getName(hashId);\n            }\n            styleStr += `${styleName}:${formatValue};`;\n          }\n          const actualValue = (_a = value === null || value === void 0 ? void 0 : value.value) !== null && _a !== void 0 ? _a : value;\n          if (typeof value === 'object' && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {\n            actualValue.forEach(item => {\n              appendStyle(key, item);\n            });\n          } else {\n            appendStyle(key, actualValue);\n          }\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = `{${styleStr}}`;\n  } else if (layer && supportLayer()) {\n    const layerCells = layer.split(',');\n    const layerName = layerCells[layerCells.length - 1].trim();\n    styleStr = `@layer ${layerName} {${styleStr}}`;\n    // Order of layer if needed\n    if (layerCells.length > 1) {\n      // zombieJ: stylis do not support layer order, so we need to handle it manually.\n      styleStr = `@layer ${layer}{%%%:%}${styleStr}`;\n    }\n  }\n  return [styleStr, effectStyle];\n};\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nfunction uniqueHash(path, styleStr) {\n  return hash(`${path.join('%')}${styleStr}`);\n}\n// function Empty() {\n//   return null;\n// }\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  const styleContext = useStyleInject();\n  const tokenKey = computed(() => info.value.token._tokenKey);\n  const fullPath = computed(() => [tokenKey.value, ...info.value.path]);\n  // Check if need insert style\n  let isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && styleContext.value.mock !== undefined) {\n    isMergedClientSide = styleContext.value.mock === 'client';\n  }\n  // const [cacheStyle[0], cacheStyle[1], cacheStyle[2]]\n  useGlobalCache('style', fullPath,\n  // Create cache if needed\n  () => {\n    const {\n      path,\n      hashId,\n      layer,\n      nonce,\n      clientOnly,\n      order = 0\n    } = info.value;\n    const cachePath = fullPath.value.join('|');\n    // Get style from SSR inline style directly\n    if (existPath(cachePath)) {\n      const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);\n      if (inlineCacheStyleStr) {\n        return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];\n      }\n    }\n    const styleObj = styleFn();\n    const {\n      hashPriority,\n      container,\n      transformers,\n      linters,\n      cache\n    } = styleContext.value;\n    const [parsedStyle, effectStyle] = parseStyle(styleObj, {\n      hashId,\n      hashPriority,\n      layer,\n      path: path.join('-'),\n      transformers,\n      linters\n    });\n    const styleStr = normalizeStyle(parsedStyle);\n    const styleId = uniqueHash(fullPath.value, styleStr);\n    if (isMergedClientSide) {\n      const mergedCSSConfig = {\n        mark: ATTR_MARK,\n        prepend: 'queue',\n        attachTo: container,\n        priority: order\n      };\n      const nonceStr = typeof nonce === 'function' ? nonce() : nonce;\n      if (nonceStr) {\n        mergedCSSConfig.csp = {\n          nonce: nonceStr\n        };\n      }\n      const style = updateCSS(styleStr, styleId, mergedCSSConfig);\n      style[CSS_IN_JS_INSTANCE] = cache.instanceId;\n      // Used for `useCacheToken` to remove on batch when token removed\n      style.setAttribute(ATTR_TOKEN, tokenKey.value);\n      // Dev usage to find which cache path made this easily\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_CACHE_PATH, fullPath.value.join('|'));\n      }\n      // Inject client side effect style\n      Object.keys(effectStyle).forEach(effectKey => {\n        if (!globalEffectStyleKeys.has(effectKey)) {\n          globalEffectStyleKeys.add(effectKey);\n          // Inject\n          updateCSS(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {\n            mark: ATTR_MARK,\n            prepend: 'queue',\n            attachTo: container\n          });\n        }\n      });\n    }\n    return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];\n  },\n  // Remove cache if no need\n  (_ref, fromHMR) => {\n    let [,, styleId] = _ref;\n    if ((fromHMR || styleContext.value.autoClear) && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK\n      });\n    }\n  });\n  return node => {\n    return node;\n    // let styleNode: VueNode;\n    // if (!styleContext.ssrInline || isMergedClientSide || !styleContext.defaultCache) {\n    //   styleNode = <Empty />;\n    // } else {\n    //   styleNode = (\n    //     <style\n    //       {...{\n    //         [ATTR_TOKEN]: cacheStyle.value[1],\n    //         [ATTR_MARK]: cacheStyle.value[2],\n    //       }}\n    //       innerHTML={cacheStyle.value[0]}\n    //     />\n    //   );\n    // }\n    // return (\n    //   <>\n    //     {styleNode}\n    //     {node}\n    //   </>\n    // );\n  };\n}\n// ============================================================================\n// ==                                  SSR                                   ==\n// ============================================================================\nexport function extractStyle(cache) {\n  let plain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const matchPrefix = `style%`;\n  // prefix with `style` is used for `useStyleRegister` to cache style context\n  const styleKeys = Array.from(cache.cache.keys()).filter(key => key.startsWith(matchPrefix));\n  // Common effect styles like animation\n  const effectStyles = {};\n  // Mapping of cachePath to style hash\n  const cachePathMap = {};\n  let styleText = '';\n  function toStyleStr(style, tokenKey, styleId) {\n    let customizeAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const attrs = _extends(_extends({}, customizeAttrs), {\n      [ATTR_TOKEN]: tokenKey,\n      [ATTR_MARK]: styleId\n    });\n    const attrStr = Object.keys(attrs).map(attr => {\n      const val = attrs[attr];\n      return val ? `${attr}=\"${val}\"` : null;\n    }).filter(v => v).join(' ');\n    return plain ? style : `<style ${attrStr}>${style}</style>`;\n  }\n  const orderStyles = styleKeys.map(key => {\n    const cachePath = key.slice(matchPrefix.length).replace(/%/g, '|');\n    const [styleStr, tokenKey, styleId, effectStyle, clientOnly, order] = cache.cache.get(key)[1];\n    // Skip client only style\n    if (clientOnly) {\n      return null;\n    }\n    // ====================== Style ======================\n    // Used for vc-util\n    const sharedAttrs = {\n      'data-vc-order': 'prependQueue',\n      'data-vc-priority': `${order}`\n    };\n    let keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs);\n    // Save cache path with hash mapping\n    cachePathMap[cachePath] = styleId;\n    // =============== Create effect style ===============\n    if (effectStyle) {\n      Object.keys(effectStyle).forEach(effectKey => {\n        // Effect style can be reused\n        if (!effectStyles[effectKey]) {\n          effectStyles[effectKey] = true;\n          keyStyleText += toStyleStr(normalizeStyle(effectStyle[effectKey]), tokenKey, `_effect-${effectKey}`, sharedAttrs);\n        }\n      });\n    }\n    const ret = [order, keyStyleText];\n    return ret;\n  }).filter(o => o);\n  orderStyles.sort((o1, o2) => o1[0] - o2[0]).forEach(_ref2 => {\n    let [, style] = _ref2;\n    styleText += style;\n  });\n  // ==================== Fill Cache Path ====================\n  styleText += toStyleStr(`.${ATTR_CACHE_MAP}{content:\"${serializeCacheMap(cachePathMap)}\";}`, undefined, undefined, {\n    [ATTR_CACHE_MAP]: ATTR_CACHE_MAP\n  });\n  return styleText;\n}","map":{"version":3,"names":["_extends","hash","unitless","compile","serialize","stringify","contentQuotesLinter","hashedAnimationLinter","useStyleInject","ATTR_CACHE_PATH","ATTR_MARK","ATTR_TOKEN","CSS_IN_JS_INSTANCE","supportLayer","useGlobalCache","removeCSS","updateCSS","computed","canUseDom","ATTR_CACHE_MAP","existPath","getStyleAndHash","serializeCacheMap","isClientSide","SKIP_CHECK","MULTI_VALUE","normalizeStyle","styleStr","serialized","replace","isCompoundCSSProperty","value","injectSelectorHash","key","hashId","hashPriority","hashClassName","hashSelector","keys","split","map","k","_a","fullPath","trim","firstPath","htmlElement","match","slice","length","join","globalEffectStyleKeys","Set","_cf","process","env","NODE_ENV","clear","undefined","parseStyle","interpolation","config","arguments","root","injectHash","parentSelectors","layer","path","transformers","linters","effectStyle","parseKeyframes","keyframes","animationName","getName","parsedStr","style","flattenList","list","fullList","forEach","item","Array","isArray","push","flattenStyleList","originStyle","_keyframe","mergedStyle","reduce","prev","trans","visit","call","Object","subInjectHash","mergedKey","nextRoot","startsWith","childEffectStyle","appendStyle","cssKey","cssValue","linter","styleName","toLowerCase","formatValue","actualValue","layerCells","layerName","uniqueHash","useStyleRegister","info","styleFn","styleContext","tokenKey","token","_tokenKey","isMergedClientSide","mock","nonce","clientOnly","order","cachePath","inlineCacheStyleStr","styleHash","styleObj","container","cache","parsedStyle","styleId","mergedCSSConfig","mark","prepend","attachTo","priority","nonceStr","csp","instanceId","setAttribute","effectKey","has","add","_ref","fromHMR","autoClear","node","extractStyle","plain","matchPrefix","styleKeys","from","filter","effectStyles","cachePathMap","styleText","toStyleStr","customizeAttrs","attrs","attrStr","attr","val","v","orderStyles","get","sharedAttrs","keyStyleText","ret","o","sort","o1","o2","_ref2"],"sources":["C:/Users/lenovo/Desktop/glang-gin-vue3/ginBlog/web/admin/node_modules/ant-design-vue/es/_util/cssinjs/hooks/useStyleRegister/index.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport hash from '@emotion/hash';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from '../../linters';\nimport { useStyleInject, ATTR_CACHE_PATH, ATTR_MARK, ATTR_TOKEN, CSS_IN_JS_INSTANCE } from '../../StyleContext';\nimport { supportLayer } from '../../util';\nimport useGlobalCache from '../useGlobalCache';\nimport { removeCSS, updateCSS } from '../../../../vc-util/Dom/dynamicCSS';\nimport { computed } from 'vue';\nimport canUseDom from '../../../../_util/canUseDom';\nimport { ATTR_CACHE_MAP, existPath, getStyleAndHash, serialize as serializeCacheMap } from './cacheMapUtil';\nconst isClientSide = canUseDom();\nconst SKIP_CHECK = '_skip_check_';\nconst MULTI_VALUE = '_multi_value_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr) {\n  const serialized = serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return typeof value === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);\n}\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  const hashClassName = `.${hashId}`;\n  const hashSelector = hashPriority === 'low' ? `:where(${hashClassName})` : hashClassName;\n  // 注入 hashId\n  const keys = key.split(',').map(k => {\n    var _a;\n    const fullPath = k.trim().split(/\\s+/);\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    let firstPath = fullPath[0] || '';\n    const htmlElement = ((_a = firstPath.match(/^\\w+/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;\n    return [firstPath, ...fullPath.slice(1)].join(' ');\n  });\n  return keys.join(',');\n}\n// Global effect style will mount once and not removed\n// The effect will not save in SSR cache (e.g. keyframes)\nconst globalEffectStyleKeys = new Set();\n/**\n * @private Test only. Clear the global effect style keys.\n */\nexport const _cf = process.env.NODE_ENV !== 'production' ? () => globalEffectStyleKeys.clear() : undefined;\n// Parse CSSObject to style content\nexport const parseStyle = function (interpolation) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    root,\n    injectHash,\n    parentSelectors\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    root: true,\n    parentSelectors: []\n  };\n  const {\n    hashId,\n    layer,\n    path,\n    hashPriority,\n    transformers = [],\n    linters = []\n  } = config;\n  let styleStr = '';\n  let effectStyle = {};\n  function parseKeyframes(keyframes) {\n    const animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      const [parsedStr] = parseStyle(keyframes.style, config, {\n        root: false,\n        parentSelectors\n      });\n      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;\n    }\n  }\n  function flattenList(list) {\n    let fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(originStyle => {\n    // Only root level can use raw string\n    const style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += `${style}\\n`;\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      const mergedStyle = transformers.reduce((prev, trans) => {\n        var _a;\n        return ((_a = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a === void 0 ? void 0 : _a.call(trans, prev)) || prev;\n      }, style);\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(key => {\n        var _a;\n        const value = mergedStyle[key];\n        if (typeof value === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          let subInjectHash = false;\n          // 当成嵌套对象来处理\n          let mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          let nextRoot = false;\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          const [parsedStr, childEffectStyle] = parseStyle(value, config, {\n            root: nextRoot,\n            injectHash: subInjectHash,\n            parentSelectors: [...parentSelectors, mergedKey]\n          });\n          effectStyle = _extends(_extends({}, effectStyle), childEffectStyle);\n          styleStr += `${mergedKey}${parsedStr}`;\n        } else {\n          function appendStyle(cssKey, cssValue) {\n            if (process.env.NODE_ENV !== 'production' && (typeof value !== 'object' || !(value === null || value === void 0 ? void 0 : value[SKIP_CHECK]))) {\n              [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach(linter => linter(cssKey, cssValue, {\n                path,\n                hashId,\n                parentSelectors\n              }));\n            }\n            // 如果是样式则直接插入\n            const styleName = cssKey.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n            // Auto suffix with px\n            let formatValue = cssValue;\n            if (!unitless[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {\n              formatValue = `${formatValue}px`;\n            }\n            // handle animationName & Keyframe value\n            if (cssKey === 'animationName' && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {\n              parseKeyframes(cssValue);\n              formatValue = cssValue.getName(hashId);\n            }\n            styleStr += `${styleName}:${formatValue};`;\n          }\n          const actualValue = (_a = value === null || value === void 0 ? void 0 : value.value) !== null && _a !== void 0 ? _a : value;\n          if (typeof value === 'object' && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {\n            actualValue.forEach(item => {\n              appendStyle(key, item);\n            });\n          } else {\n            appendStyle(key, actualValue);\n          }\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = `{${styleStr}}`;\n  } else if (layer && supportLayer()) {\n    const layerCells = layer.split(',');\n    const layerName = layerCells[layerCells.length - 1].trim();\n    styleStr = `@layer ${layerName} {${styleStr}}`;\n    // Order of layer if needed\n    if (layerCells.length > 1) {\n      // zombieJ: stylis do not support layer order, so we need to handle it manually.\n      styleStr = `@layer ${layer}{%%%:%}${styleStr}`;\n    }\n  }\n  return [styleStr, effectStyle];\n};\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nfunction uniqueHash(path, styleStr) {\n  return hash(`${path.join('%')}${styleStr}`);\n}\n// function Empty() {\n//   return null;\n// }\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  const styleContext = useStyleInject();\n  const tokenKey = computed(() => info.value.token._tokenKey);\n  const fullPath = computed(() => [tokenKey.value, ...info.value.path]);\n  // Check if need insert style\n  let isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && styleContext.value.mock !== undefined) {\n    isMergedClientSide = styleContext.value.mock === 'client';\n  }\n  // const [cacheStyle[0], cacheStyle[1], cacheStyle[2]]\n  useGlobalCache('style', fullPath,\n  // Create cache if needed\n  () => {\n    const {\n      path,\n      hashId,\n      layer,\n      nonce,\n      clientOnly,\n      order = 0\n    } = info.value;\n    const cachePath = fullPath.value.join('|');\n    // Get style from SSR inline style directly\n    if (existPath(cachePath)) {\n      const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);\n      if (inlineCacheStyleStr) {\n        return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];\n      }\n    }\n    const styleObj = styleFn();\n    const {\n      hashPriority,\n      container,\n      transformers,\n      linters,\n      cache\n    } = styleContext.value;\n    const [parsedStyle, effectStyle] = parseStyle(styleObj, {\n      hashId,\n      hashPriority,\n      layer,\n      path: path.join('-'),\n      transformers,\n      linters\n    });\n    const styleStr = normalizeStyle(parsedStyle);\n    const styleId = uniqueHash(fullPath.value, styleStr);\n    if (isMergedClientSide) {\n      const mergedCSSConfig = {\n        mark: ATTR_MARK,\n        prepend: 'queue',\n        attachTo: container,\n        priority: order\n      };\n      const nonceStr = typeof nonce === 'function' ? nonce() : nonce;\n      if (nonceStr) {\n        mergedCSSConfig.csp = {\n          nonce: nonceStr\n        };\n      }\n      const style = updateCSS(styleStr, styleId, mergedCSSConfig);\n      style[CSS_IN_JS_INSTANCE] = cache.instanceId;\n      // Used for `useCacheToken` to remove on batch when token removed\n      style.setAttribute(ATTR_TOKEN, tokenKey.value);\n      // Dev usage to find which cache path made this easily\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_CACHE_PATH, fullPath.value.join('|'));\n      }\n      // Inject client side effect style\n      Object.keys(effectStyle).forEach(effectKey => {\n        if (!globalEffectStyleKeys.has(effectKey)) {\n          globalEffectStyleKeys.add(effectKey);\n          // Inject\n          updateCSS(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {\n            mark: ATTR_MARK,\n            prepend: 'queue',\n            attachTo: container\n          });\n        }\n      });\n    }\n    return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];\n  },\n  // Remove cache if no need\n  (_ref, fromHMR) => {\n    let [,, styleId] = _ref;\n    if ((fromHMR || styleContext.value.autoClear) && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK\n      });\n    }\n  });\n  return node => {\n    return node;\n    // let styleNode: VueNode;\n    // if (!styleContext.ssrInline || isMergedClientSide || !styleContext.defaultCache) {\n    //   styleNode = <Empty />;\n    // } else {\n    //   styleNode = (\n    //     <style\n    //       {...{\n    //         [ATTR_TOKEN]: cacheStyle.value[1],\n    //         [ATTR_MARK]: cacheStyle.value[2],\n    //       }}\n    //       innerHTML={cacheStyle.value[0]}\n    //     />\n    //   );\n    // }\n    // return (\n    //   <>\n    //     {styleNode}\n    //     {node}\n    //   </>\n    // );\n  };\n}\n// ============================================================================\n// ==                                  SSR                                   ==\n// ============================================================================\nexport function extractStyle(cache) {\n  let plain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const matchPrefix = `style%`;\n  // prefix with `style` is used for `useStyleRegister` to cache style context\n  const styleKeys = Array.from(cache.cache.keys()).filter(key => key.startsWith(matchPrefix));\n  // Common effect styles like animation\n  const effectStyles = {};\n  // Mapping of cachePath to style hash\n  const cachePathMap = {};\n  let styleText = '';\n  function toStyleStr(style, tokenKey, styleId) {\n    let customizeAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const attrs = _extends(_extends({}, customizeAttrs), {\n      [ATTR_TOKEN]: tokenKey,\n      [ATTR_MARK]: styleId\n    });\n    const attrStr = Object.keys(attrs).map(attr => {\n      const val = attrs[attr];\n      return val ? `${attr}=\"${val}\"` : null;\n    }).filter(v => v).join(' ');\n    return plain ? style : `<style ${attrStr}>${style}</style>`;\n  }\n  const orderStyles = styleKeys.map(key => {\n    const cachePath = key.slice(matchPrefix.length).replace(/%/g, '|');\n    const [styleStr, tokenKey, styleId, effectStyle, clientOnly, order] = cache.cache.get(key)[1];\n    // Skip client only style\n    if (clientOnly) {\n      return null;\n    }\n    // ====================== Style ======================\n    // Used for vc-util\n    const sharedAttrs = {\n      'data-vc-order': 'prependQueue',\n      'data-vc-priority': `${order}`\n    };\n    let keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs);\n    // Save cache path with hash mapping\n    cachePathMap[cachePath] = styleId;\n    // =============== Create effect style ===============\n    if (effectStyle) {\n      Object.keys(effectStyle).forEach(effectKey => {\n        // Effect style can be reused\n        if (!effectStyles[effectKey]) {\n          effectStyles[effectKey] = true;\n          keyStyleText += toStyleStr(normalizeStyle(effectStyle[effectKey]), tokenKey, `_effect-${effectKey}`, sharedAttrs);\n        }\n      });\n    }\n    const ret = [order, keyStyleText];\n    return ret;\n  }).filter(o => o);\n  orderStyles.sort((o1, o2) => o1[0] - o2[0]).forEach(_ref2 => {\n    let [, style] = _ref2;\n    styleText += style;\n  });\n  // ==================== Fill Cache Path ====================\n  styleText += toStyleStr(`.${ATTR_CACHE_MAP}{content:\"${serializeCacheMap(cachePathMap)}\";}`, undefined, undefined, {\n    [ATTR_CACHE_MAP]: ATTR_CACHE_MAP\n  });\n  return styleText;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}